import Foundation
import CryptoKit

public enum CachePathResolver {
    case murmur
    case sha256
    case sha512
    case custom((Data) -> String)

    func path(for key: String) -> String {
        path(for: Data(key.utf8))
    }

    func path(for key: Data) -> String {
        switch self {
        case .murmur:
            return murmur3_32(key)
        case .sha256:
            return SHA256.hash(data: key)
                .compactMap { String(format: "%02x", $0) }
                .joined()
        case .sha512:
            return SHA512.hash(data: key)
                .compactMap { String(format: "%02x", $0) }
                .joined()
        case .custom(let resolver):
            return resolver(key)
        }
    }
}

/// A static seed to use when generating hashed paths for cached files.
/// Using a static seed ensures that the same path is generated by the
/// algorithm between subsequent runs, which is extremely important :)
///
/// Cocoa is bad.
let staticSeed: UInt32 = 0xbadc0c0a

func murmur3_32(_ key: Data, _ seed: UInt32 = staticSeed) -> String {
    let c1: UInt32 = 0xcc9e2d51
    let c2: UInt32 = 0x1b873593
    let r1: UInt32 = 15
    let r2: UInt32 = 13
    let m: UInt32 = 5
    let n: UInt32 = 0xe6546b64
    let bytes = Array(key)
    var hash = seed
    let k: (UInt32) -> UInt32 = { ((($0 &* c1) << r1) | (($0 &* c1) >> (32 - r1))) &* c2 }
    for i in stride(from: 0, to: bytes.count - 3, by: 4) {
        let slice = bytes[i..<(i + 3)]
        var word = slice.dropFirst()
            .enumerated()
            .reduce(UInt32(slice[i])) { result, next in
                result | UInt32(next.element) << (8 * (next.offset + 1))
        }
        word ^= k(word)
        var newHash = hash
        newHash = newHash ^ k(word)
        newHash = (newHash << r2) | (newHash >> (32 - r2)) &* m &+ n
        hash = newHash
    }
    let remaining = bytes.count & 3
    if remaining != 0 {
        hash ^= k((0..<remaining).reduce(UInt32(0)) { result, next in
            result | (UInt32(bytes[bytes.count - 1 - next]) << (8 * (remaining - 1 - next)))
        })
    }
    let truncatedCount = UInt32(truncatingIfNeeded: bytes.count)
    hash ^= truncatedCount
    hash ^= (hash >> 16)
    hash = hash &* 0x85ebca6b
    hash ^= (hash >> 13)
    hash = hash &* 0xc2b2ae35
    hash ^= (hash >> 16)
    return String(format: "%02x", hash)
}
