import Foundation

/// A static seed to use when generating hashed paths for cached files.
/// Using a static seed ensures that the same path is generated by the
/// algorithm between subsequent runs, which is extremely important :)
///
/// Cocoa is bad.
let staticSeed: UInt32 = 0xbadc0c0a

func murmur3_32(_ key: String, _ seed: UInt32 = staticSeed) -> String {
    return murmur3_32(key.data(using: .utf8)!)
}

func murmur3_32(_ key: Data, _ seed: UInt32 = staticSeed) -> String {
    let c1: UInt32 = 0xcc9e2d51
    let c2: UInt32 = 0x1b873593
    let r1: UInt32 = 15
    let r2: UInt32 = 13
    let m: UInt32 = 5
    let n: UInt32 = 0xe6546b64
    let bytes = Array(key)
    var hash = seed
    let k: (UInt32) -> UInt32 = { ((($0 &* c1) << r1) | (($0 &* c1) >> (32 - r1))) &* c2 }
    for i in stride(from: 0, to: bytes.count - 3, by: 4) {
        let slice = bytes[i..<(i + 3)]
        var word = slice.dropFirst()
            .enumerated()
            .reduce(UInt32(slice[i])) { result, next in
                result | UInt32(next.element) << (8 * (next.offset + 1))
        }
        word ^= k(word)
        hash = ((word << r2) | (word >> (32 - r2))) &* m &+ n
    }
    let remaining = bytes.count & 3
    if remaining != 0 {
        hash ^= k((0..<remaining).reduce(UInt32(0)) { result, next in
            result | (UInt32(bytes[bytes.count - 1 - next]) << (8 * (remaining - 1 - next)))
        })
    }
    let truncatedCount = UInt32(truncatingIfNeeded: bytes.count)
    hash ^= truncatedCount
    hash ^= (hash >> 16)
    hash = hash &* 0x85ebca6b
    hash ^= (hash >> 13)
    hash = hash &* 0xc2b2ae35
    hash ^= (hash >> 16)
    return String(format: "%02x", hash)
}
